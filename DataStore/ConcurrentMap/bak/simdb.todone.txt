
// plan: 
// - ConcurrentHash is a lava_vec and is at the start of the memory
// - ConcurrentStore takes up the rest of the memory
// | - ConcurrentStore is made up of ConcurrentList at the start of its memory
// | - block memory is everything after ConcurrentList
// - The order ends up being ConcurentHash, ConcurrentList, then block storage


// -todo: hash key data instead of the block index of the key
//       --create function to hash arbitrary bytes 
//       --create function to put into a hashmap with a pre-hashed value
// -todo: make bitwise compare function between blocks
// -todo: make a function to compare a block to an arbitrary byte buffer
// -todo: change store_kv to use compare exchange and return previous kv ?
// -todo: make remove function for ConcurrentStore? - just use free
// -todo: remove overwritten indices from the ConcurrentStore
// -todo: figure out why "wat" and "wut" match - 3 bugs: unsigned size_t in the blockcompare function, not flipping the signs of the next index when it is negative (for length), default value of true when while loop ends from the blocks comparing as false
// -todo: figure out why second insert is putting EMPTY_KEY for key and value in the hash map - comp returns true even though strings are different?
// -todo: use match function instead of block comparison for everything? better for continguous memory anyway?
// -todo: fix not finding a key too long to fit in block - wasn't updating the current block index in the loop
// -todo: return an error on running out of blocks - done with a negative blockcount if not enough blocks are available
// -todo: free blocks if not enough block are allocated
// -todo: fix infinite loop on free - last block wasn't getting next block index set when reaching LIST_END 
// -todo: deal with memory / allocate from  shared memory
// -todo: make a membuf class that encapsulates a shared memory buffer / memory mapped file on windows or linux
// -todo: make remove function
// -todo: add const to thread safe functions
// -todo: figure out why readers is so high - uninitialized KV struct in a put function
// -todo: do KV structs need versions? can an identical KV struct ever be inserted? only if the List somehow gave up identical indices, which shouldn't happen?
// -todo: test deletion from db
// -todo: check when reading if something is marked for deletion and return 0 / EMPTY_KEY if it is
// -todo: make remove function concurrent and account for the number of readers
// -todo: make remove decremented the readers but don't actually delete, so that the last reader out would delete, maybe just make a flag as mark for deletion?
// -todo: make addReaders not add any readers below zero
// -todo: figure out how to deal with deletion when there is a concurrent write - reset the readers and hash?
// -todo: make -1 an error instead of returning a length of 0? - distinguising a key with length 0 and no key could be useful 
// -todo: is only the key being deleted? - no, but vals should be removed before keys to keep the order more consistent, all other things being equal
// -todo: need to fix ConcurrentList free? it writes to the list before the compare_swap has gone through? - no, because writing to taken indices in the list doesn't matter + only one thread should be freeing a specific index at a time - if two threads were freeing the same index on top of each other, a problem bigger than atomics would be that even if both operations went through, there would be a double free
// -todo: change public get methods to use read - took out one get and changed the other to being private getFromBlkIdx
// -todo: fix shared memory aligned allocation
// -todo: make SharedMem check if the mem file already exists
// -todo: test opening the db from multiple processes - didn't work at first, likely because the copy constructor was not deleted and the destructor was run early
// -todo: test lava_vec with external memory
// -todo: convert ConcurrenList to use lava_vec
// -todo: fix hash function hashing string() different from const char* - off by one error was hashing an extra 32 bits
// -todo: fix block memory being written but get() not working (ConcurrentList not correct yet?) - hash problem, not ConcurrentList problem
// -todo: need to make ConcurrentList a flat data structure so it can be store at the start of the memory mapped file
// -todo: make ConcurrentHash flat using lava_vec
// -todo: make Store and Hash both take bool for ownership to decide whether or not to init
// -todo: test using the db from multiple processes
// -todo: make simdb read the sizes from the the database - if the Store uses the size as the head and the hashmap is sized larger than the number of blocks, how to get the number of elements? - made 12 bytes at the start of the shared memory
// -todo: store blockSize and blockCount and flags in the starting three ui64 slots
// -todo: make flag to see if the db has been initialized yet to mitigate race conditions on creating and opening the memory mapping
// -todo: make post build run a copy command for an extra .exe that can be run while the primary exe is overwritten by the compiler
// -todo: figure out why memory is different on second run - why does "wat" get inserted again? - working as intended?
// -todo: try zeroing memory of each block on free - works, just needs two memset() calls just as there are two free() calls to the list
// -todo: move block lists to a lava_vec
// -todo: figure out why memory seem correct but get is not working - just the check of readers being below or equal to zero
// -todo: make decReaders run doFree ? 
// -todo: add readers inc and dec to matching - made memcmpBlk function
// -todo: test db.rm 
// -todo: make readers on a per block level
// -todo: make free decrement block readers
// -todo: move readers to the ConcurrentStore
// -todo: make comparison function in ConcurrentHash that increments and decrements reader
// -todo: should rm on the last put erase their memory? - yes, wasn't resetting readers
// -todo: figure out why get returns -1  -  no return statement, just empty probedKv.key; 
// -todo: figure out why get after put isn't working - was switching the order of readers and index in BlkLst struct
// -todo: figure out why put after rm doesn't show up with get - readers not being reset on allocation? - forgot to take out the free-ing in put() 
// -todo: make both free and read give back a block with last one out strategy
// -todo: test again with multiple processes after redoing rm() technique - without put deleting old elements, how to get rid of overwritten elements? - needed to put back deleting in put(), but make sure rm() swaps in EMPTY_KEY
// -todo: make rmHashed return EMPTY_KEY on MATCH_REMOVED
// -todo: take readers out of hash struct 
// -todo: move hash functions to be static instead of member functions
// -todo: look up better hash function - fnv
// -todo: clean up fnv
// -todo: try making macro with ALLOCA to create a stack based lava_vec
// -todo: load blockSize and blockLength from existing shared memory
// -todo: make function to query size - simb.len(key)
// -todo: make setting the key flag be the last thing when allocating 
// -todo: have last one out remove hash index
// -todo: add removal of blocks to CH doFree ? - no, simdb does that
// -todo: make incReaders for ConcurrentHash
// -todo: have to make hash the authority, give KV struct a reader count
// -todo: put incReaders and decReaders around match function call in ConcurrentHash functions
// -todo: make setting the key flag be the first thing when freeing - actually done in decReaders
// todo: make indexed list of keys
//       -create a bitset in the ConcurrentHash? - can't use ConcurrentHash because blocks could change after query
//       -bitset has to be atomic? - can't create bitset because the key flag, reader count, and index all have to be together?
// done  -use key flag in Block Index struct, treat the entire thing as a 64 bit atomic
// done  -iterate through BlkLst vector to find the next key - done in ConcurrenHash
// done  -after a key is found, get the length of that block index
// done    -when getting the length, check if the block is a key, if not, return an error
// done    -check if the key is not empty
// done    -check if the readers is not less than 0
//       -after getting the length, read from the block index, again checking if the block index is a key and if not, returning an error 
// -todo: can cleanup be done by checking the CH entry after read and setting a flag to delete the old version? - no, because this would only shield one overlap, if more threads were swapping CH entries, they would have to wait/spinlock
// -todo: do a write up on if linear search is neccesary because a hash could land on a KV that has readers as -1 ?  - no different than any other hash map? - search stops on an empty key, but it shouldn't stop on readers<0 ? what happens if a key is inserted a few slots from where the hash lands, then the original landing place is removed? does the empty key stop the search?
// -todo: work out how doFree from ConcurrentHash connects to removing blocks - will need to be done with versioning
// -todo: do a write up on overall structure
// -todo: implement get that takes an index into ConcurrentHash - 0 length does nothing, length must be inout, if key is empty or readers is < 0, make length 0 and do nothing 
// -todo: test looking up values from the iterated keys
// -todo: make sure when looping through keys, that readers is not negative? all reads must be atomic? all BlkLst must have their original index embedded? ConcurrentHash does need readers after all?
// -todo: change pointers to shared memory to have a s_ prefix
// -todo: add version and remove readers from ConcurrentHash struct
// -todo: initialize s_version to 1 if owner==true
// -todo: make LIST_END constant
// -todo: need to have a version with each block and store it with each non head BlkIdx as well as the key value pair of ConcurrentHash - how many bits for the version? 32 bits to start? - just needs to be enough so that a so many blocks can't be gotten while a thread is stalled that the version wraps back around
// -todo: have to put version in concurrent hash so that an overwrite from a new write won't cause an ABA problem with another thread reading from it, then decrementing readers?
// -todo: make writeBlock have an optional start and end
// -todo: add length and key length to ConcurrentStore
// -todo: change to single block index key value pairs
// -todo: fix extra memory writing bug with byte key and 3 byte value
// -todo: test with more inserts and different blockSizes
// -todo: need more data with BlkIdx so that blocks read are known to be from the correct key value pair - do with versions
// -todo: make memcmpBlk take a length parameter - already there
// -todo: redo compare to only compare key
// -todo: fix total len in BlkLst - runMatch returned boolean
// -todo: first pass of changing void* to void const* const so that STL pointers can be used directly
// -todo: change put to use constant void* buffers
// -todo: make version make it into ConcurrentHash KV
// -todo: make writeBlock only take a length parameter since the input pointer can be offset by the caller - no! the offest is about where to write in the block, not about the incoming buffer 
// -todo: redo ConcurrentStore.len() to take a version and output an optional klen
// -todo: re-implement simdb.len to output len and keylen
// -todo: redo matching with version checking 
// -todo: make matching take a length that it won't exceed - already done by comparing both key length and version
// -todo: make ConcurrentStore.get take a length that it won't exceed - will happen by comparing lengths when get() is redone
// -todo: combine keys and data into one block run
// -todo: make sure that a block isn't read from if readers<0
// -todo: flip decReaders return value - no, because the return value is 'do I need to clea up'
// -todo: take value key from KV struct in ConccurrentHash and use VerIdx instead
// -todo: redo ConcurrentStore.get() to use single index block lists
// -todo: make readBlock() take an offset
// -todo: work out offset in store.get()
// -todo: make len() give back the length of the value
// -todo: test get()
// -todo: make nxtBlock() take a version number - instead just return a VerIdx struct
// -todo: implement simdb.get()
// -todo: take out size_t from ConcurrentStore
// -todo: give put() return type a BLKIDX type - no need for now, eventually will want to return a VerIdx ? 
// -todo: implement C++ get(str)
// -todo: test key iteration
// -todo: redo nxt() - needed a VerIdx that was the hashmap index combined with the version
// -todo: put maxlength in readBlock()
// -todo: figure out why getKey() is empty - get() was being used which gets the value and not the key
// -todo: redo simdb functions to use runRead - used runRead and runMatch
// -todo: organize all C++ functions separate from C functions so that they can be #ifdef out if used as a C library
// -todo: make len be a direct lookup somehow? - if ConcurrentHash is the authority, len can be done the same way as an  empty/full bitset ? 
// -todo: take out simdb::read()
// -todo: take out simdb::SpinWhileFalse() ?
// -todo: commit and push to git
// -todo: change hash loop to use modulo
// -todo: take out getHashed findHashed 
// -todo: change ConcurrentHash to no longer be only powers of 2
// -todo: make alloc give back blocks if allocation fails
// -todo: need to make free and decReaders take versions? - yes because any removal needs a version, since once readers is decremented below 0 it is no longer guaranteed to not be swapped out with something else by a different thread
// -todo: make a C++ string get just return an empty string on error?
// -todo: make a get all keys function
// -todo: figure out why not all keys are retrieved - they were, but starting with an empty string added an empty string to the set

// -todo: redo concurrent store get to store length so that buffer can be returned
// -todo: change string to pass through to c_str() and const char* overload
// -todo: take out power of 2 size restriction and use modulo
// -todo: use blockSize and blockCount from the already created shared mem if not the owner
// -todo: store size in the ConcurrentList? list isn't atomic so it should work well? should block lists, key sizes, and val sizes all be in their own lava_vecs ? 
// -todo: store lengths and check key lengths before trying bitwise comparison as an optimization? - would only make a difference for long keys that are larger than one block? no it would make a difference on every get?
// -todo: move to using packed key value in one block list
// -todo: can block sync be done with a removed flag instead of just using readers? - no, the problem is that if another thread is reading, how do you know if another thead is not reading? 
// -todo: change lava_vec name to flat_vec? - not now 

// -todo: combine key and value storage so they are packed together in the same block list?
// -todo: mark free cells as negative numbers so double free is caught? - do it only in debug mode? - doesn't seem neccesary 
// -todo: make erase function that 0s out bytes? - only in debug mode? - not now
// -todo: Make block size for keys different than data? - not needed with unified key and value storage
// -todo: lock init with mutex? - not needed by using spinlock
// -todo: implement locking resize? - not now
// -todo: should the readers be integrated with the list also? - done
// -todo: make SharedMemory take an address and destructor, or make simdb take an address and destructor to use arbitrary memory? - maybe later

//Block based allocation
//-Checking if the head has been touched means either incrementing a counter every time it is written, or putting in a thread id every time it is read or written
//-Each ui32 in a vector holds the position of the next free block 
//-Alloc checks the head to read the next free position and puts it in head if head hasn't been touched. 
//-Free checks the head to read the next free position, stores the head value in the free position, then moves head to the just written new free position if head hasn't been touched

// not now - idea: use max_waste as a recipricol power of two giving the percentage of waste allowed for an allocation
// - 2 would be 25%, 3 would be 12.5% 
// - not allowed to be below 2
// -done idea: put atomic reader counter into each ConcurrentStore entry as a signed integer
// -done idea: figure out how to make ConcurrentHash a flat data structure so it can sit in shared memory




// 4.29.2017
// -todo: test 128 bit atomics
// -todo: find memory corruption bug on looping insert of random numbers - just put key where value should be in C++ string put
// -todo: figure out why all keys are being printed - getKeys() returns a single empty string
// -todo: figure out why getKeys returns one empty string - for short blocks, the last block is a key/starting block because it is also the first block. The make_BlkLst function made non keys have length and key length automatically set to 0.
// -todo: figure out why duplicate keys aren't overwriting each other - putHashed needs to match without using version, then compare and swap using version, checking the match each time
// -todo: test with multiple threads in a loop
// -todo: take out infinite loop possibility in rm
// -todo: take out any inf loops in runMatch
// -todo: change getKeyStrs() to get the number looped through by nxtKey() so it isn't O(n^2)
// -todo: put in osx stuff here - likely mmmap with shared memory
// -todo: try using NtOpenFile
// -todo: make a standard "simdb" shared memory file that contains the paths of all other shared memory files? - not needed for now
// -todo: make realloc that changes the size of a block list - would have to find a way to not break concurrency to be able to resize block lists, with reference counting and some sort of flag, it would still be the same as blinking the key out of existence while a thread updates the block list size
// -todo: make windows version have permissions for just read and write
// -todo: check if memset to 0 is still anywhere in the release build - line 1827 still has a memset to 0 on free
// -todo: get compiler warning out of windows build - just need to take out unneccesary headers and copy in any struct and function definitions?
// -todo: make function to swap two VerIdxs of ConcurrentHash
// -todo: make function to swap the hi and low 32 bits of VerIdx, swapping the order
// -todo: make sure that versions for even and odd VerIdx are kept to be even and odd version numbers - odds need to start at 1 and both need to be incremented by 2
// -todo: make VerIdx layout in ConcurrentHash have a ping pong memory layout
// -todo: make 128 bit swap increment both versions - no need
// -todo: make versions increment by 2 - no need, versions come from the block version
// -todo: make 128 bit atomic function
// -todo: make resize function so block lists can be resized rather than freed, only to be reallocated - doesn't work like this!
// -todo: convert to 64 bit integers - not now, just need to clean up type aliases and signs
// -todo: test windows permissions - ok now that \\Global isn't used and the shared memory 'Segment' goes into the current session?
// -todo: take out WINNT namespace for windows NT definitions
// -todo: make readers for blocks only exist on the head of the list? - not needed
// -todo: move make_BlkLst to constructor
// -todo: change BlkLst union to hold hash values
// -todo: writeup why robin hood hashing will work for put, get, and delete (and their interactions)
// -todo: store hash of key in ConcurrentStore
// -todo: make alloc give back the blocks if allocation fails - already done
// -todo: make sure when comparing VerIdxs that they compare both the version and the index - already done, compared as a single 64 bit int ?
// -todo: make sure ConcurrentStore.put() tests each block for LIST_END - not needed because alloc checks for LIST_END
// -todo: make the BlkLst hash be checked before comparing keys
// -todo: make ConcurrentStore get() stop before exceeding maxlen? - already done
// -todo: clean up type aliases with ui32 to u32
// -todo: make arguments to listDBs for the prefix? 'type' is windows specific and should be ok to be hardcoded - not neccesary because windows will be hardcoded and unix and linux don't have types
// -todo: make a macro to have separate windows and unix paths
// -todo: initialize ConcurrentHash with a pointer to ConcurrentStore
// -todo: change rm() to del()
// -todo: change i8* to u8* and ui8* to u8*
// -todo: get rid of unused uiX type aliases
// -todo: take out IDX alias
// -todo: make del() delete a VerIdx, duplicate the VerIdx ahead into the deleted slot, check that the indices are the same, and if they are, mark the one further ahead as deleted
// -todo: make a DELETED value for hash entries so that when something is removed, it doesn't block a linear search
// -todo: take out stack based m_blocksUsed
// -todo: give a ConcurrentStore pointer to ConcurrentHash 
// -todo: change ConcurrentHash  to CncrHsh or LfHsh
// -todo: change ConcurrentStore to CncrStr
// -todo: change ConcurrentList  to CncrLst
// -todo: make compexchange_kv take VerIdx instead u64
// -todo: make deleted_i64 function - made a vi_i64 function instead
// -todo: make deleted indices that have an empty index on their right side become empty indices
// -todo: take out simdb_ prefix? - if this happens, how will listDBs be able to find, think about this later, an answer will likely become clear
// -todo: change compexchange_kv to cmpex_vi
// -todo: need to do anything special to guarantee that readers is aligned so it is atomic? - no it is 64 bit so alignement doesn't matter for atomicity and barely matters for performance
// -todo: clean up inconsitent signs and usage of negative numbers - VerIdx and BlkLst both have i32 for their idx field
// -todo: switch negative numbers to a bitfield struct instead of implicitly using the sign bit for different purposes - use a bitfield struct with a flag for hitting LIST_END for out_blocks in alloc()
// -todo: this conflates and assumes that EMPTY_KEY is both the CncrStr block index EMPTY_KEY and the CncrHsh EMPTY_KEY - probably fine
// -todo: use the VersionIdx struct with the return from alloc()
// -todo: stop using lambdas and templates - step 1, moving functions to CncrHsh
//       | len()
//       | get()
//       | del()
//       | put()
// -todo: stop using match function as a template in del() 
// -todo: change load_kv and store_kv to load_vi and store_vi
// -todo: check the hash in each BlkLst index as an early out for failed reads - already done through CncrStr::compare()
// -todo: get() - short circuit as not found on finding an empty slot - will need a deleted value - already was returning false on EMPTY, but needed to keep going on DELETED_KEY
// -todo: check if reads can be made non-atomic if they already aren't - not worth looking in to now
// -todo: redo EMPTY_KEY and DELETED_KEY to use last two values of u32
// -todo: put supporting windows functions into anonymous namespace - only typedefs needed to be outside the anonymous namespace
// -todo: put prefetching into reading of blocks - put in to nxtBlock()
// -todo: look at making a memory access to the next block that can't be optimized away
// -todo: prefetch memory for next block when looping through blocks - does this require a system call for shared memory and does it lock? it should just be the prefetch instruction or an unoptimized away load? use intrinsic?
// -todo: change CncrStr::get() to check the version after reading and not before - is this not technically correct!!1! this checks that the next version is the same and then reads it, but shouldn't it read the block and then check if the version is still the same? - version is checked in readblock already
// -todo: fix infinite loop on put
// -todo: fix infinite loop on delete
// -todo: make a swapped VerIdx type? - no because it won't do any good due to the VerIdx struct being used moslty to store the info on the stack and store it in memory 
// -todo: make sure that 128 bit atomics are actually being called - breakpoint is hit when setting inside the function
// -todo: refine putHashed to have proper names
// -todo: change CncrStr::free() to take a VerIdx instead of separate variables? - might as well not 
// -todo: fix infinite loop when deleting "wat" for the second time - alloc was not setting the first BlkLst index correctly
// -todo: re-evaluate CncrHsh main loops' back tracking on compare exchange failure - just use prevIdx(i) - could use a goto to the top of the loop to avoid running prevIdx and then nxtIdx
// -todo: make cmpex_vi swap hi and lo on odd indices - also had to feed it the actual address of the shared memory vi instead of the address of the copied (and possibly swapped)
// -todo: rename m_kvs to m_vis
// -todo: flatten putHashed into having the block comparison embedded 
// -todo: print or visualize CncrHsh 
// -todo: rename m_vis to s_vis since it is a lava_vec of Version Indexes in shared memory
// -todo: debug compare exchange not working - dereferencing a pointer passed to the function failed silently while returning true - the value needed to be assigned to another local variable and that variable used as a reference
// -todo: redo alloc so that there isn't a branch in the BlkLst construction
// -todo: debug len returning 0 when key seems to exist in memory - not making it in to CncrHsh? - not using the shared memory for CncrHsh finally causing a problem? - put() not setting the hash? - alloc() was not setting the hash correctly
// -todo: redo CncrHsh to use the shared memory instead of the lava_vec allocated on heap mistake - will this require aligning to 128 bit memory?
// -todo: make BlkLst hash 64 bits instead of 32? - leave this until there is a reason to change it 
// -todo: make put return a bool and output the index in a separate out variable? -  make put give back FAILED_PUT on error - isn't EMPTY_KEY enough? - no, because the put might fail due to no blocks left
// -todo: make put return VerIdx ? - is having an out_version pointer enough? - revisit this if it becomes an issue
// -todo: redo the BlkLst struct with calibrated bitfield size and without sub structures
// -todo: debug new BlkLst struct with get() / len() no longer working - put() seems to work, len() seems to not work -  incReaders() and decReaders() needed a union of isKey and readers to be an integer
// -todo: change CncrHsh init to set ints directly instead of using store_vi
// -todo: make alloc() set up a list with LIST_END as the last index
// -todo: redo KeyReaders, incReaders() and decReaders()



// 5.4.2017
// -todo: make CncrLst::idx() an atomic load
// -todo: figure out why neither version of CncrStr::free() is being hit - wasn't calling del()....
// -todo: figure out 128 bit alignement of CncrHsh's VerIdx memory - padded sizeBytes() by 16 and offset the address in which the lava_vec is created with to land on the 128 bit boundary
// -todo: debug clean deletions leaving slots in a DELETED_KEY state - one side of the 128 bit alignment not being swapped - now duplicate DELETED_KEY entries are being created without being cleaned up - also deleting an adjacent EMPTY? - had to switch around bit swapping functions, lo and hi now only describe the low and high addresses
// -todo: figure out how to set the indices into a list in CncrLst so that free() can use the start and end indices to free multiple blocks
// -todo: make a CncrStr function to free a series of blocks with a begin and end, returning failure or success
// -todo: make bulk free by setting all list blocks first, then freeing the head of the list - does only the head of the list need to be freed anyway since the rest of the list is already linked together? could this reduce contention over the block atomic?
// -todo: Make frees happen from the last block to the first so that allocation might happen with contiguous blocks
// -todo: does a BlkLst need to be loaded atomically by a read operation? is it possible that a read could be out of date and use an incorrect cached version? - a thread will eventually atomically decrement the readers after reading all the blocks so it should be fine 
// -todo: try to take out checkMatch from CncrHsh - checkMatch is unused
// -todo: debug some (all?) CncrHsh indices not being deleted - only the last index? - cmpex_vi was being used with a pointer into s_vis on some functions and a pointer to a swapped vi on the stack in other functions
// -todo: redo simdb::len(blkIdx) to fit the functions as they stand now - klen and vlen were labeled out_vlen and out_version 
// -todo: take out runRead - used by direct simdb::len(blkIdx) function - also used by getKey - was previously used to wrap incReaders() and decReaders() calls around a function 
// -todo: flatten runIfMatch function to only take a function template argument but not a match function template argument - take it out all together
// -todo: figure out what to do about indices on the ends in CncrHsh - just leave a DELETED_KEY and don't turn it into an EMPTY, since it will then just be skipped over when looking for an index - make sure that cleanDeletion() and delDupe() skip the last index when they are the primary/left/lo index
// -todo: make sure that the start and end are taken care of with regards to cleaning up deletions - need to not go off the end of the array and need to figure out how to deal with spans between them
// -todo: stop using match function as a template in and just run a function in CncrHsh
//       | len()
//       | get()
//       | put()
// -todo: find any remnants of KeyVal or kv and change them to VerIdx or vi
// -todo: redo basic type definitions and put them only into class definitions
// -todo: debug larger key not being found - length not being stored in every BlkLst
// -todo: test with larger keys and values that span multiple blocks
// -todo: re-evaluate if the high bits of the lava vec pointer still need to contain extra information - one bit is being used for ownership - it can probably be made into a flat only container and ownership can just be a matter of who runs the constructor
// -todo: compile with maximum warnings - warnings /all gives warning on the standard library and functions not being inlined - warning level 4 has no issues except for the errant potential mod by 0
// -todo: create public close function that will also be called on destruction
// -todo: reference count initializations so that the last process out can destroy the db
// -todo: make sure that the linked list of BlkLst structures is re-initialized on freeing - does head need to also make sure that it's version never uses a special value like 0 or LIST_END?
// -todo: make a special version number that is checked for and skipped
// -todo: debug len(idx) returning 0 - is free resetting the block indices causing problems? -  no, len() wasn't looking up from the CncrHsh first and getIdx() was returning false when less or equal to DELETED_KEY and not greater or equal
// -todo: test with visualizer
// -todo: make lava_vec flat only so that it never needs to be destructed
// -todo: make lava_vec pointer point to 16 bytes in, giving operator[] a way to dereference the memory without any additional offsets
// -todo: make memcmpBlk return MATCH_REMOVED if the key was deleted
// -todo: make sure readers checks the version number after reading each block when finding a key - doesn't matter since for now readers is incremented and decremented
// -todo: make sure readers is only used on the key block list - should be fine
// -todo: make sure readers deletes the block list if it is the last reader after deletion - still true
// -todo: build in the ability to explicitly set the path of the shared memory file - relative paths work, but absolute paths on windows don't seem to 
// -todo: test flush() - doesn't seem to write to the file leave for now
// -todo: search for any embedded todo comments
// -todo: run existing tests - some bugs fixed, one outstanding CncrHsh slot is not being deleted - possibly because it is in a 128 bit alignment at the end of the VerIdx array with another DELETED_KEY ahead of it
// -todo: make cleanDeletion and delDupe() set a DELETED_KEY TO EMPTY_KEY if there is an EMPTY_KEY behind it
// -todo: change to just DELETED and EMPTY instead of DELETED_KEY and EMPTY_KEY
// -todo: redo cleanDeletion to detect if the next slot is the end of a span and change the current slot to EMPTY if it is  
// -todo: make cleanDeletion and delDupe() check forward if setting the current slot to EMPTY_KEY based on the previous idx - can't set based on the previous index because you can't know atomically what the next index is
// -todo: when searching for a match, never treat the last index as the end of a span, and always set the last slot directly to EMPTY instead of DELETED - can't do that because the second to last index could erroneously be set to EMPTY
// -todo: look back at cleanDeletion() for how to handle version mismatch - just return since not being deleted but having a version mismatch means the nxtVi is stale and the thread that deleted it should be cleaning it up
// -todo: add a len() that takes a std::string
// -todo: figure out why some deletions are failing - cleanDeletions() has some side effect where the hashs don't match - take out cleanDeletions() all together, save for another time
// -todo: figure out why non-deleted keys are not listed in printkeys() - bug in getting keys
// -todo: figure out why third key entry is not being found despite being in the block memory - getKeys() loop needed to be redone
// -todo: change VerStr to have str and ver intead of s and v
// -todo: test inserting more than the total size of memory - seems to return false just fine
// -todo: figure out why only one key is returned by getKeys() when there are more in memory - starting point was 0, which made getting the element at 0 be treated as if it has searched the whole db and wrapped back around



