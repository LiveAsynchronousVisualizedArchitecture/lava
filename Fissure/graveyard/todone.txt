// -todo: put loop into LavaFlow IMPL 
// -todo: put loop dependent functions into the anonymous namespace
// -todo: take out LavaId implicit cast from u64 - already done earlier
// -todo: break out the loop function
// -todo: work out getting size of out of a node - make room for both reference counts and the size in bytes in the allocation
// -todo: make helper LavaMem struct
// -todo: partition owned memory with a zero reference count, free them and finally erase them from the vector
// -todo: make the lava allocator passed to a node allocate an extra 8 bytes for the reference count 
//       |  make sure that extra data at the beggining is treated atomically
//       |  make sure that memory is allocated aligned to a 64 byte cache line
// -todo: put packet arguments into the InArgs array and use it to decrement references after the the function has ran
// -todo: does the input arg need a slot number? do the slot numbers just need to be used to place it in the array - put in slot for now 
// -todo: make owned memory vector use the thread local allocation
// -todo: make LavaAlloc use LavaHeapAlloc 
// -todo: make message passing nodes a set instead of a vector 
// -todo: figure out why delNode is passed a wrong node id - is it LavaNode::NONE ?  - pointer / iterator was being invalidated by deletion
// -todo: make sel_delete delete from the message passing nodes set - nothing was deleting from the LavaGraph
// -todo: figure out why a deleted node id shows up - is it not being deleted from the msg passing nodes? 
// -todo: put some output in simdb
// -todo: make initializer list run the main init function in tbl - actually need to split the fields initialization from any alloction 
// -todo: split table printing into multiple functions
// -todo: take owned() query out of internal cp() function? - done, but crash still happens, possibly on destroy() during copy
// -todo: make initializer list not use emplace, but copy to indices, since the array elements already exist
// -todo: figure out why flattening the tbl is not working - is the type of the child table not the same on each run? - is flatten not making a child table into a child table type when it is internal? - possible problems with shrink_to_fit()
// -todo: either visualize strings, or put an indexed verts object into the db - probably easier to make another node that outputs an indexed verts table - node that outputs IdxVerts created
// -todo: fix selection again
//       -| figure out all information like the slot and node that's inside, box drag etc click up or down etc, 
//       -| redo connection creation
//       -| redo primary node selection with reordering
//       -| put it all together at the end 
// -todo: make basic command queue - enum for command, priority number - use std::pri_queue - use u32 for command, use two u64s for the arguments  - not neccesary with selection refactoring
// -todo: take out clear node selections
// -todo: take out node state selection on primary selection
// -todo: fix title changing on node deletion - title was changed to the last key pressed 
// -todo: make nanogui message bar at the bottom
// -todo: make status bar show information about the selection 
// -todo: make popup over each node that shows statistics and information like the node number - status bar will take care of this for now
// -todo: fix current node in top right corner - m_curId initialized to LavaNode::NONE instead of 0
// -todo: compile visualizer in release mode - doesn't work the same as debug mode - even debug seemingly calls into eigen at unrelated times while stepping through
// -todo: put in right button mouse states and right mouse clicks
// -todo: make a hook function for LavaFlow to call after every packet
// -todo: make 64 bit atomic ring buffer to know if a Node / slot should be put into the db - just a Set with linear comparisions, not a ring buffer, not hash based
// -todo: make packet callback check if a node-slot combination is in the array of Ids that need to be written - if the node-slot Id is in the vizualize array, then put it into the db
// -todo: separate out slot key creation for deletion
// -todo: fix AtmSet del - compare and swap called with argument order flipped
// -todo: delete a buffer from the visualization DB using the main GUI thread when deleting from the atomic set of visualized slots
// -todo: when turning off a slot, delete the entry from the database 
// -todo: make right clicking on slot visualize that slot with a combination of the text label, node id and slot id  as the db key
// -todo: make play execute a stop() first
// -todo: make play be greyed out while running
// -todo: make play, pause and stop have different colors
// -todo: change status bar on mouse over instead of click
// -todo: try wrapping 'structured exception handling' - just needed to wrap the structured exception handling in a dedicated function
// -todo: fix infinite loop when deleting from the db when the key is not found - needed to end the loop after looping through all the keys - when ending the loop, needed to return empty
// -todo: put background highlights on visualized slots
// -todo: take out Id type alias
// -todo: fix deletion - make delete and backspace delete selected nodes - might need to check the primary selection as well as selection states - sel_nodes now includes the primary selection as well
// -todo: use exceptions to flag node instances 
// -todo: build in a state variable to the LavaInst struct
// -todo: create red background highlights on nodes that generate exceptions
// -todo: build in the atomic store and load functions into the LavaInst struct
// -todo: make exceptions in the shared library functions put the packet back into the queue
// -todo: make nodes highlight on mouse over - white with 0.025 opacity seems to work well to be able to see when a node is moused over
// -todo: put timer into each node instance - try C++11 high resolution clock now() with doubles
// -todo: make status bar show the timing data for each node
// -todo: make time adding atomic
// -todo: make time reset on stop
// -todo: make time totaling function for the LavaGraph
// -todo: make the status bar update continuously even for the last moused over node? - need to keep the last node in the global state - just use the primary selection
// -todo: make command queue for LavaGraph so that changes to the graph can be stored and queued
// -todo: finish using cur() functions
// -todo: fix slot movement - src and destination were flipped in the toggle command
// -todo: make LavaFlow loop always use the right buffer
// -todo: make LavaGraph edit functions use the opposite buffer
// -todo: fix LavaGraph - figure out why there are slots that are [0:0] - sel_clear() was setting current slots to LavaId(0,0)
// -todo: figure out how to create slots from commands when the slots need the Node Id - use a stack of return values
// -todo: change node_add to use commands - how can slots get the sid back from the commands being run? - return stack args from exec() in a vector()?
// -todo: use command queue to batch commands, execute them, and switch the data structures 
// -todo: convert lava graph changes to use the command queue
// -todo: make two graphs and switch back and forth with an atomic bool
//       | -should there be two graphs, one read and one write 
//       | -make sure that the write has a mutex or some sort of locking - don't need a mutex if there is a bool that switches buffers and the commands are sent and executed from a single thread
//       | -do commands only need two arguments? one or two LavaIds with a command enum
// -todo: fix slots not showing up - nodeSlots() needed a const and non-const version, each of which uses a different buffer
// -todo: fix node selection being inverted
// -todo: convert LavaFlow to class with const LavaGraph const& function to access the graph as read only - similiar approach using dual buffers taken
//       | -does there need to be a function to copy the instances and connections? - should this ultimatly be used for drawing the graph? - this is done in the exec() function befoe executing the command queue
//       |  can the graph be condensed into a tbl ? 
// -todo: use a copy of the graph to clear and update the interface buttons - not neccesary due to the LavaGraph dual buffers? 
// -todo: make a function to get a copy of the graph - can check the version number every loop, and if it is higher, get a copy of all the data inside a mutex - not neccesary from the dual buffers
// -todo: make frame queue
// -todo: make LavaFrame struct
// -todo: make slotCount() count the number of bits in the slotMask
// -todo: make an atomic frame number part of LavaNodeInst and a method to fetch_add to it
// -todo: make LavaFlowFunc take a LavaFrame as input 
// -todo: make a putSlot function for LavaFrame
// -todo: find a single message node and run that - should there be a global next message node index or should there be a next message node per thread? - single global atomic is simplest and possibly still very good solution - message nodes are not in an array, they are in a ahash
// -todo: make sure to only run message nodes when there are no more outstanding packets
// -todo: fix probable race condition of updating the cache of indices - make a cache as another A/B member of 
// -todo: fix crash on msg node - didn't switch the flow loop to use the graph's id cache
// -todo: make sure to run a single packet on each increment through the main loop - done with the single nxtPacket call that switches to trying a message node if none are found
// -todo: set a node's state to error if the loading doesn't work
// -todo: figure out a way to query the next message node directly, since an index from the index cache to a query to the msg node could have a change in the middle
// -todo: break out status text creation into separate function
// -todo: clamp status text at 100% of time per node
// -todo: figure out why frame rate seems clamped to 144 - does having two monitors with the same refresh rate, turn vsync for windows back on and vsync glfw? - not sure, but a glfw swap interval of 0 and 1 seem to do the same thing - 24hz desktop means 24fps GUI even with a swap interval of 0
// -todo: test message node to flow node - doesn't crash, but message node is also not highlighted
// -todo: make sure LavaFrame path actually runs the node - is the packet making it out of the message node?
// -todo: make LavaFrame have a source frame number and a dest frame number - not used right now - LavaFrame frame number comes from the first packet, which should also be looking for packets of the same frame number
// -todo: change the decrementing of references to look into the LavaFrame passed in instead of LavaArgs, right now it will not have an effect
// -todo: make slot loop only check if they are taken or not
// -todo: separate out bitset - use std::bitset instead
// -todo: change LavaFrame bitset names - taken out due to bitset
// -todo: type notes for flat_lockfree_map
// -todo: work on flat lock free map
// -todo: make an atomic bitset
// -todo: test atomic bitset
// -todo: use AtomicBitset in LavaFrame
// -todo: make LavaFrame operations atomic - need an atomic bitset 
// -todo: put priority into packets 
// -todo: put a range in a packet - does this imply the generation of multiple smaller packets from one bigger packet that then have to be synced together?
// -todo: figure out a way to emit multiple packets with different ranges - with lava_emit() it should be possible to emit multiple packets that reference the same data and have different ranges - what happens if the first packet is emitted, then consumed, then the reference count is decremented to 0 before the next packet is emitteed? - nothing, because the memory won't be freed until the thread gets out of the node and loops around, so the reference count becoming 0 while the node is still running is not a problem
// -todo: define filesystem namespace by compiler and not OS
// -todo: make priority part of LavaPacket operator< 
// -todo: make a queue for output arguments that uses the thread local heap
// -todo: change project name to Fissure
// -todo: make an assert if more than one thread does a push
// -todo: make a queue that carries its allocation and deallocation functions with it as pointers so that it can be passed to a .dll
//       | -with two buffers and only one thread writing, the structure can be different -make queue use a read buffer and a write buffer - the write buffer will only be used by the thread that owns the queue, so there won't need to be a write lock
// -todo: rework lavaQ to have a cur and an end
// -todo: make read happen inside a compare_exchange loop - added without a loop, pop fails on contention 
// -todo: change project name to Fissure 
// -todo: test LavaQ
// -todo: make a template to run an arbitrary function on the StEnBuf - just copy and paste for now
// -todo: make a union that will hold the st, en and buffer boolean
// -todo: possibly make cur, end, and buffer boolean into a single struct of 31, 31, and 1 bits - buffer and capacity need to be in the same struct - can combining everything in to single atomics be avoided by using an A and B variable for each?
// -todo: change lava_theadQ to lava_outQ? lava_threadOutQ? - LavaQ is fined
// -todo: can the start and buf flag in the queue be put together while leaving the end and capacity separate?  - might need to leave start and end together so that the reading threads are always in sync with the writing thread, though maybe it is fine
// -todo: make LavaFrame slots start from the begining - not neccesary with output queue
// -todo: make deallocation happen just before it is needed
// -todo: change StEnBuf to StBuf
// -todo: make sure that different StBuf structs have different integer respresentations - integer representations are more legible with the buffer switch bit first
// -todo: redo memory allocation sequence so that the buffers are always pointing to allocated memory - should they also be atomic?
// -todo: make memory pointers into atomics
// -todo: make a custom copy function that takes in to account wrapping
// -todo: fix concurrent pop returning unitialized memory 
// -todo: clean up LavaQ
// -todo: make LavaQ::size() take into account wrapping
// -todo: make StBuf::st be incremented by the new capacity so that it wraps around to the same spot yet is a different number - have to increment m_end first? can their wrapped versions be used? - prove that buf.st can't overflow 
// -todo: work around st == en being empty and full - expand happens when buffer has one slot left, instead of no slots left
// -todo: only need to change buf.st on every other buffer flip
// -todo: make at() functions increment and decrement reference counts 
// -todo: put reference count as well as deleted flag into the pointers for memA and memB
// -todo: add reference count for each buffer
// -todo: try StBuf with 6 bits for the current capacity - if the buffer is flipped, it should go up by one - what should be done on shrink? - doesn't seem neccesary 
// -todo: use an array of reference counted buffers? - doesn't seem neccesary
// -todo: think of a way to make sure that the buffer can't be double flipped during a read - can m_end be checked to see if it hasn't increased by the capacity before the read? - if the buffers have been switched twice, that means that m_end must have been incremented by at least the current capacity, to make that happen - maybe an idea for later
// -todo: reset buf.st if it gets bigger than double capacity - not neccesary when not using extra increment tricks
// -todo: clean unused line out of LavaQ again
// -todo: test LavaQ with explicity malloc and free + thread local allocations - free needed to use the stored function pointer in m_free in 3 different places
// -todo: put capacity into StBuf, since the array index is the combination of the constantly incrementing st variable and the capacity of that buffer
//       | -change StBuf to have 6 bits for capacity
//       | -make push / expand put capacity into StBuf
//       | -make pop use the StBuf capacity
//       | -test - fix blank output
//       | -take out m_capA and m_capB
// -todo: profile LavaQ
// -todo: profile LavaQ with only one thread calling pop()
// -todo: template LavaQ
// -todo: test std::queue - about 3 times faster to only push() 100 million integers
// -todo: compile with LavaQ instead of std::queue
// -todo: integrate MakeCube into Fissure to try out the new LavaQ
// -todo: make packets be emitted (lava_send() ?) instead of simply returned
// -todo: define a const LavaNodeEnd
// -todo: make template visual studio project file
// -todo: embed visual studio template and node cpp template
// -todo: make a button to create a node directory, project and cpp file
// -todo: fix vc proj xml 
// -todo: replace the node name in the cpp file with |_NAME_|
// -todo: use regex to substitute the node name into the cpp and project files 
// -todo: put |_NAME_| in for cpp file in the project file
// -todo: put |_NAME_| in for the function name in cpp file
// -todo: make slot mask have a const operator[]
// -todo: use std::array for static packet array so that it can be iterated through 
// -todo: clean up comments in LavaFlow.hpp
// -todo: visualize packets being routed - can the current queue simply be read and drawn by the interface? - seems so, though it locks for now
// -todo: expand the margin around flow nodes so that the slots don't obscure the text - need to make the node width dependant on the text bounds in the first place
// -todo: visualize packets at outputs and frames at inputs/nodes? - packets already are on slots, and the 'current node' highlights should represent a frame being run
// -todo: visualize packets being created - halos around slots for all packets in the queue
// -todo: calc text size + margins before node drawing so that bounding boxes are correct (for both selection and slot drawing)
// -todo: fix play being grayed out on pause
// -todo: put total outstanding packet size (in bytes) in the status bar
// -todo: make nodes a little fatter or slots offset a little more from the edge
// -todo: make assert to check if the mem in nullptr - make a debug function for the end of a node that has its body empty in release mode - make the packet q be checked in debug mode somehow
// -todo: figure out why PrintLavaMem crashes even while checking for ptr == nullptr - LavaMem is just a pointer moved back a few dozen bytes to point to the start of a lava allocation instead of just the start of the data portion - if LavaOut::value is 0, LavaMem::ptr will end up wrapping around in the negative and be a large number
// -todo: fix packet sz_bytes parameter - just needed to be initialized
// -todo: draw a number inside the slot - not neccesary if the slot information is in the status bar on mouse over
// -todo: make a constructor for LavaOut
// -todo: figure out why MakeCube is giving an error - queued LavaOuts that were set to nullptr were not being removed after being detected, and later nodes run by the same thread were giving errors
// -todo: make 'stop' clear packets and errors
// -todo: visualize a slot - already works
// -todo: keep state in make cube so it only emits once - done with an atomic boolean but does not reset on 'stop'
// -todo: popup the slots string name in the status bar - only needed to reorder status bar if statements
// -todo: put slot name in the status bar of slot mouse over
// -todo: put slot type in the status bar
// -todo: fix slots labels - lower slot indices were outputs, higher were inputs
// -todo: put error type in the status bar on mouse over of a errored node
// -todo: figure out why passing memory through creates a crash - possible duplications create a double free scenario? - seems to be the case - only have to sort the already partitioned memory with a reference count of zero, then skip over duplicates, all the zero referenced memory are already partitioned and will be erased anyway
// -todo: make a node that passes cube through
// -todo: visualize the passed through memory - visualizes on output - passed through node was not setting the slot of its output value
// -todo: get input slot to be visualized - needed to give the packet callback a packet with the dest node and slot set
// -todo: make a new output type of passthrough, that does not make an entry in owned mem - no longer need to sort memory allocations to eliminate duplicates?
// -todo: make a node to transform the cube from MakeCube
// -todo: draw node names after the slots so the text is on top? - not neccesary with enough margin
// -todo: make button that creates a project for a node - would it need to pop up a modal dialog? - done with a button and a text field
// -todo: test LavaQ across shared library borders - seems to work
// -todo: integrate type into LavaMem instead of as part of the LavaMem struct so that it can be queried externally - may have to revisit this
// -todo: look at LavaParams now that it doesn't need to be written to by the node - designated as const and outputs taken out 
// -todo: take LavaMsg out
// -todo: make LavaMem use a struct for layout of bytes - only two header members, not neccesary 
// -todo: unify LavaOut and LavaVal
// -todo: make lava allocation function put the new allocation into the current thread's owned mem vector instead of having it happen outside the loop - this will mean no more need for duplicate allocation checking and passthrough types
// -todo: test without putting allocated point in owned memory to see the result of a memory leak - big time memory leak, rapid increase in memory used
// -todo: take out sorting and duplicate detection in thread owned memory dealloction
// -todo: move dealing with the output queue out of the run func function
// -todo: look into why deleting a message node makes packet visualization go away - getting the next message node id might need to be modulo with the number of nodes total, not just with the number of msg nodes - nxtMsgId was being used for the packet ID, so with 2 message nodes only one would ever get run
// -todo: retstructure how the packet callback is handled
// -todo: give message passing nodes constructors and destructors 
// -todo: make constructor and destructor be run on initialization
// -todo: look in to crashes happening in the visualizer with constantly updated items - are they nanogui crashes unrelated to database updates? is the creation and deletion of nanogui widgets not thread safe?
// -todo: make constructor run on start and destructor run on stop - should destructors and constructors simply both run on stop?
// -todo: use MakeCube to test constructor and destructor
// -todo: make pause and stop buttons greyed out until playing
// -todo: copy template back in to FissureStatic.cpp
// -todo: make visualizing an input actually toggle visualization on the the output it is attached to
// -todo: make packet visualization also include lighting up connections between slots
// -todo: make packetSlots an unordered_set instead of a vector
// -todo: use new tbl.hpp to re-implement IdxVerts - don't use an array, use only named sub-tables
// -todo: test an IdxVerts tbl and put it into the Fissure db to test with brandisher
// -todo: debug why mode is not showing up - being overwritten by another key before flattening
// -todo: implement sub tables in brandisher
// -todo: look in to turning tbl into class without a template
// -todo: convert tbl.hpp to no longer be a template - characters "u8", "iu8", "f64", for the type of array - can any heirarchy of initializer_lists be brought down to an array of the same types?
// -todo: redo MakeCube with new tbl format
// -todo: test IdxVerts without non essential components like texture coordinates or colors
// -todo: put image into IdxVerts
// -todo: use recursive tbls to make an image - actually it is only one tbl down, the img doesn't contain sub tables
// -todo: make triangle test into a square - right triangle is enough to show image
// -todo: make a card that has an image on it to test an IdxVerts with an image - triangle with UVs is enough
// -todo: figure out if nanogui is taking characters as events so they don't get repeated as hotkeys in the node window - just need to check the bool of nanogui to see if the character was passed through to a component

