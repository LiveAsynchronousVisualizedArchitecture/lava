

// -todo: make push and push_back
// -todo: make pop() and pop_back()
// -todo: fix realloc to be resize based on element count
// -todo: operator >> for concatenation with left keys as priority
// -todo: operator << for concatenation with right keys as priority
// -todo: make reserve()
// -todo: keep track of capacity and make capacity() const function
// -todo: make front() and back()
// -todo: make key value pair be 4 bytes for hash, 18 + 1 for c_str(), and 8 + 1 for variant + type - should be 32 bytes - with 8 bytes for hash and type -> 36 bytes + 28 more bytes for key str = 64 bytes? - this_is18_char_key | hsh+type -> 8 bytes, 
// -todo: make tbl_tell that uses printf - can't because it won't detect the types like iostream will
// -todo: make tbl_assert
// -todo: make assignment operator
// -todo: test single kv implicit cast
// -todo: make template specialization strings to print out types - possible but opted for a switch jump table at run time since it should only be used during debugging and run time type strings will be needed for hsh.type anyway
// -todo: make tbl_assert a function - can't make it a function because of expression printing and line numbers
// -todo: make tbl assert have error message
// -todo: make tbl_assert back into a macro
// -todo: fill out the rest of the type nums
// -todo: fill out the rest of the type strings
// -todo: make as<>() template function
// -todo: make and test destructor
// -todo: make move constructor
// -todo: make hash union
// -todo: try in release mode - find and fix release mode crash - first try at destructors didn't work
// -todo: make copy constructor and assignment operator
// -todo: test and fix destructor crash - reversed boolean of m_mem
// -todo: make bool implicit cast that evaluates pointer
// -todo: make vector expand to 8 elements minimum
// -todo: make 1 bit always indicate signed, 1 bit always indicate table, 1 bit indicate integer, and 2 bits indicate the bit depth as 3,4,5, or 6 - same 5 bits as discreet 21 types if unsigned & not integer is used for empty!
// -todo: re-test type assertions after structuring enum bits
// -todo: make variant structure
// -todo: make enum with number types and table-number types
// -todo: copy in hash function from simdb
// -todo: make elems() the number of elements in the map
// -todo: change reserve to use both size and elems 
// -todo: start on map
// -todo: store needed map data on heap - map elements and ????
// -todo: test operator()
// -todo: fix hash comparison check
// -todo: make operator() access the map
// -todo: check for a full loop around of a hash map search
// -todo: return a reference to a NONE KV if there was no space and the map search had to loop around to the end
// -todo: fix reference return to just copy the key when the key is empty and not create a new KV
// -todo: increase elems and mark type as a default (I32?) instead of EMPTY
// -todo: add type string for NONE
// -todo: make kv have implicit casts to the different number types
// -todo: make another enum type for ERROR?
// -todo: make has() function or STL equivilent - test has()
// -todo: make insert() function 
// -todo: turn operator() into a template - not needed because the reference to kv use the templated operator=
// -todo: turn insert() into a template
// -todo: test types to make sure EMPTY and NONE and ERROR are not duplicated
// -todo: make all elements initialize to zeroed out with EMPTY enum set - just need EMPTY to be default constructor
// -todo: make operator() return type ERROR if space isn't found 
// -todo: make a table hold any type, but a map hold only numbers and table-number types
// -todo: make key length a constant so that key functions that work on C strings can be limited in length
// -todo: make a double cast template function - template<class FROM, class TO> 
// -todo: figure out casting from integer to float but not float to integer - just check for float to integer scenario
// -todo: make switch statement to have flexible number casts (a ui8 can be cast without error to a ui32)
// -todo: make signed to unsigned debug catch for implicit casts
// -todo: make constructor with default value
// -todo: specialize del() function for being owned or not - template specialization of functions seems to work well
// -todo: make sure an owned tbl from a non-owned tbl copies, but a non-owned from a non-owned does not? - forget this and always copy unless there is a move?
// -todo: make operator+= 
// -todo: test operator+ with mismatched sizes
// -todo: fill out other numeric and binary operators
// -todo: make numeric operators that take a single right side number
// -todo: put in assert to check for bounds errors on debug
// -todo: make bounds checks during debug
// -todo: specialize offset type somehow?  tbl inside a tbl is given by being an offset/child and owned type. the tbl then gives up a reference/non-owned type that is not a child/offset type  - not neccesary with owned and non-owned tables
// -todo: make operator[] and operator() call template specialized functions that jump by an offset if they are a child type? - shouldn't be neccesary, because acessing a child tbl can just construct a reference type each time, using the held offset to the tbl children segment (!) - not neccesary with owned and non-owned tables
// -todo: make reserve rehash and reinsert all elements - works?
// -todo: factor in wrap aroun
// -todo: debug expand()  /  reserve with more vector capacity - not vector capacity, but mapcap with 6 instead of 4 causing problems?
// -todo: test putting more than 8 elements into map - seems broken - debug 5th element insertion - is it reserve or the collision that is the problem? - expand is the problem? it enlarges the capacity AND map_cap?
// -todo: make error messages for ERROR and NONE
// -todo: fix comapact_all removing elements - empty index wasn't being set to the current index when moving an element
// -todo: resolve 'two' conflict with duplicate keys - have to make sure each element has not empty space between its ideal position and its final position
// -todo: split operator() into a find function that returns the index of the element with the given key
// -todo: make a compact function that searches backwards to move and element back as far as possible?
// -todo: debug duplicate entries - possibly because of expand() being run
// -todo: make comapct function increment empty index instead of setting it to the moved index? - instead, make move element as far back as possible
// -todo: make a del(const char* key) function that sets the type to empty, then moves back elements until either an empty space or an element aleady in its ideal position is found  
// -todo: make function to detect holes between a key and its empty position
// -todo: try using operator() instead of place_kv
// -todo: with robin-hood hashing, would it be possible to re-insert elements, then deal with them in spans? - no because all movement creates holes
// -todo: make placement loop reset the end point and always loop to the end index
// -todo: make function to move an index forward or backward? - not needed with rolling placement reordering
// -todo: make a function to remove any holes between an element and its ideal position
// -todo: make function to find spans of non-empty blocks, sort them and move them - not needed
// -todo: simplify test case and debug duplicates in concatenation - should reserve use a del() function combined with reinsertion? 
// -todo: revisit concactenation to make sure map elems are copied
// -todo: try reserve again - without recursion? - if curKV's ideal idx is the same, loop on the next idx. - problem, robin hood hashing would mean swapping if curKV's ideal is larger than the element at i, but if an element hasn't been moved, its distance to ideal could be large, meaning it wouldn't move even though it should 
//       | solution: don't do robbin hood hasing at first, just make sure all the elements that hash to the same bucket are linearly packed
//       |   problem: are there scenarios that will trigger infinite recursion? - yes, if only comparing ideal indices
//       |   problem: moving an element creates a hole - does that mean the elements in front should be moved back if it would make them closer to their ideal index?
//       |     solution: make a delete function that removes a key and checks elements forward to see if moving them one back would get them closer to their ideal position
//       |     solution: make a compact function that scans through looking for empty spaces and moves elements backwards if it would be more ideal - make the function start at an index and go until it hits an element already in its ideal position, returning the number of elements moved
// -todo: robin hood hashing
// -todo: make put into a template
// -todo: change place_rh to return reference
// -todo: change operator() to use put - not neccesary 
// -todo: change concatenation to use put() - not needed
// -todo: make a KV constructor that takes a key, hash and a value
// -todo: debug duplicate "two" entries - rolling placement wasn't using robin hood hasing
// -todo: make KVRef struct with a *this ptr and an index - make internal and external KV structs, with the external having a this ptr that can modify the table? - not needed
// -todo: give KV a default constructor and copy constructor so that the c_str key is copied?
// -todo: put comparison into place_rh
// -todo: test KV with key string above character length - fails with an assert
// -todo: make extend() enlarge based on map_capacity() instead of elems
// -todo: make and test del() function
// -todo: make capacity be increased when elems is within 75% or 4-6 of the map capacity
// -todo: make rolling reshuffle and put into delete function - not needed, but robin hood hasing will be needed
// -todo: integrate robin hood hasing into compact() - short circuiting 
// -todo: debug del() compact() not filling in holes after first call - only short circuit after prevElemDist is lower than elemDist, not lower of equal
// -todo: test with 64 byte KV and long key strings - seems to work fine
// -todo: make rolling reorder into a function
// -todo: make function to delete KV with NONE type? set NONE to empty? - make delete type function?
// -todo: make shrink_to_fit()
// -todo: change find() ideal() distance() and holeOfst to const
// -todo: update reserve() and constructor to set map capacity
// -todo: make operator-- be shrink_to_fit() and ++ be expand() ?
// -todo: redo unsigned types to not include an 'i'




