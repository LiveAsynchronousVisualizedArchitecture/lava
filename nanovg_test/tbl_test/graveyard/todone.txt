

// -todo: solve const qualifiers
// -todo: solve operator()() producing empty keys
// -todo: put magic number in front of tbl 
// -todo: template tbl
// -todo: fix type not being set in tbl::put()
// -todo: solve map elements movement in reserve() - overlapping memory allocations with memmove and memcpy causing problems - assignemnts too - solved by byte by byte copying from the largest address address backwards 
// -todo: fix elements when size and capacity are not the same
// -todo: figure out why there are duplicate keys in the tbl - signed / unsigned mismatch between hashes
// -todo: figure out why map capacities grow when pushing to array - expand didn't discriminate between whether to expand the array or map and enlarged both 
// -todo: put back destructors on deallocation
// -todo: fix size when inserting map elements before pushing array values
// -todo: put in begin() and end() iterators
// -todo: fix tbl.put() not making it into the map - put() was close but not the same as operator() - put() now uses operator()
// -todo: make sure that the first two bytes have TB instead of the most significant little endian bits
// -todo: use memcpy in cp() - can't because of copy constructors - need to insert the elements
// -todo: make cp() copy over map elements 
// -todo: try just shifting bits to read size bytes
// -todo: make emplace() and emplace_back() methods
// -todo: put back static KV in error_kv()
// -todo: make cast types to cast to 64 bit equivilents
// -todo: cut types down to just u64, i64, double, string etc
// -todo: add childData() and childDataSize() functions
// -todo: untemplate KV
// -todo: make types for both table pointers and table offsets - not actual types, just need to be in the type enum
// -todo: copy child into child data
// -todo: increment curChild
// -todo: change KV to be an offset with an offset type
// -todo: make reserve take a child data parameter
// -todo: change tbl types to store m_mem instead of the memStart() - changed to store pointer to table itself to make things easier, not storing just the pointer to the heap
// -todo: store and retrieve a reference and a pointer to a table
// -todo: copy tbl out of a KV reference, then copy it out of a KV directly
// -todo: work on flattening tbls into with child data section
//      -| start with flattening tables into child section
//      -| still need 'table of intrinsic type' type definitions, even if the map only has 64 bit types 
//      -| is a child data offset variable needed? - can it be made from capacity, sizeof(T), and map_capacity() ? - try that first
// -todo: fix bit flags made from flipped flags
// -todo: fix type turning to EMPTY when bit combined with CHILD
// -todo: define KV struct early and fill in methods and functions later
// -todo: make a KVOfst struct that can hold a KV and an offset for the table
// -todo: make KVOfst contain just a kv reference instead of full KV
// -todo: turn fields into a struct
// -todo: make owned functions
// -todo: make cp and mv constructors use ownership flag - mv constructor can stay the same because it just copies the m_mem pointer
// -todo: make a non-owned tbl
// -todo: make destructor use ownership flag
// -todo: move ownership from the fields struct to the m_mem pointer? - if the ownership flag is set to false in the contiguous memory, no reference will delete it and the owner of the memory will eventually wipe it out
// -todo: figure out a way to make tbl work with m_mem while pointing to it directly - make m_mem = 0 and if it is 0, pretend it points to it's own location? - need to make an unowned tbl? where to put the owned bit?
// -todo: change KVOfst to use  a KV pointer instead of reference
// -todo: figure out why fields does not line up when returned as a KVOfst from operator() - was using this instead of memStart()
// -todo: retrieve child table from a flattened table
// -todo: put tbl array type data in capacity variable low bits - just use a 'type' key while first two bytes are magic number 't' and 'b'
// -todo: make operator+=(const char*) create a key in the map - operator() already does this
// -todo: work on flattening table - put in table data segment
//       -| -change map_capacity to be a variable in memory
//       -| tbl segment would be calculated from other variables - internal tbl would be an offset from m_mem
// -todo: figure out what happens when doing anything that effects the size of a child tbl - child tbl cannot have it's size changed? need two different internal tbl types, one for references(non owned) and one for children(owned) ?
//       - changing size or deleting an internal tbl means re-making the memory with another allocation and memcpy
// -todo: make non owned type always read only? - still need owned and non-owned types within tbl
// -todo: make flatten method that has creates a new tbl with no extra capacity and takes all tbl references and makes them into offset/children tbls that are stored in the sub-tbl segment - instead of child type, make a read only type? read only could have template specializations or static asserts that prevent changing the tbl or the KV objects from it
// -todo: make sure destructor is being run on objects being held once turned into a template
// -todo: make shrink_to_fit call destroy on the previous allocation
// -todo: make reserve(), expand() and shrink_to_fit() not work on non-owned tbls
// -todo: make constructor that takes only an address to the start of a tbl memory span - just has to offset it by memberBytes() - owned check in the copy constructor + move constructor takes care of this already?
// -todo: make KV.val as a child table an offset into the child data segment instead of an offset into the whole table memory
// -todo: make private byte move function
// -todo: make shrink_to_fit() take into account childData() - will need to redo both the base pointer and the tbl offset ?
// -todo: debug shrink_to_fit() tbl child data return - why is map capacity changed to 4 when reading? - when both reading or writing the table can be expanded - why does expanding break it ? - reserve didn't copy child data at all
// -todo: template table casting from KVOfst
// -todo: multiply mapcap by 8 and elems by 10, then compare sizes to get an integer only expansion at 80% full
// -todo: break out fields from template
// -todo: make flatten also shrink_to_fit()
// -todo: make get return hsh through an optional argument
// -todo: make operator() check for existence and ownership before expanding
// -todo: make KVOfst expand the tbl - would this imply that the size of the array type needs to be kept in the fields? - not neccesary with restructuring 
// -todo: make cast operator for KVOfst return false on error_kv or kv being nullptr
// -todo: make operator()() use multiple functions so that it can be read from without expansion
// -todo: split operator()() into a const and non-const version - make them use a get() function underneath - not neccesary with re-structuring
// -todo: have to handle child data copying in cp()
// -todo: test and check assigning child table to parent table
// -todo: destroy any child tables in the child data - not neccesary because they are owned memory and not any compound types with real destructors
// -todo: destroy any non-child tables in the map - if they aren't owned, don't they get destroyed anyway?
// -todo: test destruction of non-child table in a map key - if it isn't owned it would get destroyed on scope exit anyway
// -todo: try to take out make_new in operator()
// -todo: make operator()() take integers so that the map can also be used as an iterable list through sub-tables - just make operator()() take an integer offset into elemStart(), then make an iteration cursor through the non-empty elements of the map? - should this make the hash equal the integer passed or should it look up the element directly? - since elemStart() can already loop through all elements, making the integer become the hash should interlace the numbered indices with the string key hash tables - should the integer be hashed? - hashing the integer should give the advantages of a normal hash table
// -todo: make map expansion check at the end of operator() as well as the top - wouldn't the re-order where the kv could be? - just want to expand if it owned and being read - just have to use has() if you want to make sure you don't expand the map on read
// -todo: make operator-=(const char*) delete a key in the map - need to use a generic del() function - del() exists, more operator overloading won't help density much
// -todo: make put() take a KV instead of being a template - not worth the trouble right now, solution in search of a problem until it can be shown to cause bloat
// -todo: first take out all the old dealings with small bit depths
// -todo: fix normal numbers being put back into map - types constants and some templates need to  be sorted out again


// -todo: make push and push_back
// -todo: make pop() and pop_back()
// -todo: fix realloc to be resize based on element count
// -todo: operator >> for concatenation with left keys as priority
// -todo: operator << for concatenation with right keys as priority
// -todo: make reserve()
// -todo: keep track of capacity and make capacity() const function
// -todo: make front() and back()
// -todo: make key value pair be 4 bytes for hash, 18 + 1 for c_str(), and 8 + 1 for variant + type - should be 32 bytes - with 8 bytes for hash and type -> 36 bytes + 28 more bytes for key str = 64 bytes? - this_is18_char_key | hsh+type -> 8 bytes, 
// -todo: make tbl_tell that uses printf - can't because it won't detect the types like iostream will
// -todo: make tbl_assert
// -todo: make assignment operator
// -todo: test single kv implicit cast
// -todo: make template specialization strings to print out types - possible but opted for a switch jump table at run time since it should only be used during debugging and run time type strings will be needed for hsh.type anyway
// -todo: make tbl_assert a function - can't make it a function because of expression printing and line numbers
// -todo: make tbl assert have error message
// -todo: make tbl_assert back into a macro
// -todo: fill out the rest of the type nums
// -todo: fill out the rest of the type strings
// -todo: make as<>() template function
// -todo: make and test destructor
// -todo: make move constructor
// -todo: make hash union
// -todo: try in release mode - find and fix release mode crash - first try at destructors didn't work
// -todo: make copy constructor and assignment operator
// -todo: test and fix destructor crash - reversed boolean of m_mem
// -todo: make bool implicit cast that evaluates pointer
// -todo: make vector expand to 8 elements minimum
// -todo: make 1 bit always indicate signed, 1 bit always indicate table, 1 bit indicate integer, and 2 bits indicate the bit depth as 3,4,5, or 6 - same 5 bits as discreet 21 types if unsigned & not integer is used for empty!
// -todo: re-test type assertions after structuring enum bits
// -todo: make variant structure
// -todo: make enum with number types and table-number types
// -todo: copy in hash function from simdb
// -todo: make elems() the number of elements in the map
// -todo: change reserve to use both size and elems 
// -todo: start on map
// -todo: store needed map data on heap - map elements and ????
// -todo: test operator()
// -todo: fix hash comparison check
// -todo: make operator() access the map
// -todo: check for a full loop around of a hash map search
// -todo: return a reference to a NONE KV if there was no space and the map search had to loop around to the end
// -todo: fix reference return to just copy the key when the key is empty and not create a new KV
// -todo: increase elems and mark type as a default (I32?) instead of EMPTY
// -todo: add type string for NONE
// -todo: make kv have implicit casts to the different number types
// -todo: make another enum type for ERROR?
// -todo: make has() function or STL equivilent - test has()
// -todo: make insert() function 
// -todo: turn operator() into a template - not needed because the reference to kv use the templated operator=
// -todo: turn insert() into a template
// -todo: test types to make sure EMPTY and NONE and ERROR are not duplicated
// -todo: make all elements initialize to zeroed out with EMPTY enum set - just need EMPTY to be default constructor
// -todo: make operator() return type ERROR if space isn't found 
// -todo: make a table hold any type, but a map hold only numbers and table-number types
// -todo: make key length a constant so that key functions that work on C strings can be limited in length
// -todo: make a double cast template function - template<class FROM, class TO> 
// -todo: figure out casting from integer to float but not float to integer - just check for float to integer scenario
// -todo: make switch statement to have flexible number casts (a ui8 can be cast without error to a ui32)
// -todo: make signed to unsigned debug catch for implicit casts
// -todo: make constructor with default value
// -todo: specialize del() function for being owned or not - template specialization of functions seems to work well
// -todo: make sure an owned tbl from a non-owned tbl copies, but a non-owned from a non-owned does not? - forget this and always copy unless there is a move?
// -todo: make operator+= 
// -todo: test operator+ with mismatched sizes
// -todo: fill out other numeric and binary operators
// -todo: make numeric operators that take a single right side number
// -todo: put in assert to check for bounds errors on debug
// -todo: make bounds checks during debug
// -todo: specialize offset type somehow?  tbl inside a tbl is given by being an offset/child and owned type. the tbl then gives up a reference/non-owned type that is not a child/offset type  - not neccesary with owned and non-owned tables
// -todo: make operator[] and operator() call template specialized functions that jump by an offset if they are a child type? - shouldn't be neccesary, because acessing a child tbl can just construct a reference type each time, using the held offset to the tbl children segment (!) - not neccesary with owned and non-owned tables
// -todo: make reserve rehash and reinsert all elements - works?
// -todo: factor in wrap aroun
// -todo: debug expand()  /  reserve with more vector capacity - not vector capacity, but mapcap with 6 instead of 4 causing problems?
// -todo: test putting more than 8 elements into map - seems broken - debug 5th element insertion - is it reserve or the collision that is the problem? - expand is the problem? it enlarges the capacity AND map_cap?
// -todo: make error messages for ERROR and NONE
// -todo: fix comapact_all removing elements - empty index wasn't being set to the current index when moving an element
// -todo: resolve 'two' conflict with duplicate keys - have to make sure each element has not empty space between its ideal position and its final position
// -todo: split operator() into a find function that returns the index of the element with the given key
// -todo: make a compact function that searches backwards to move and element back as far as possible?
// -todo: debug duplicate entries - possibly because of expand() being run
// -todo: make comapct function increment empty index instead of setting it to the moved index? - instead, make move element as far back as possible
// -todo: make a del(const char* key) function that sets the type to empty, then moves back elements until either an empty space or an element aleady in its ideal position is found  
// -todo: make function to detect holes between a key and its empty position
// -todo: try using operator() instead of place_kv
// -todo: with robin-hood hashing, would it be possible to re-insert elements, then deal with them in spans? - no because all movement creates holes
// -todo: make placement loop reset the end point and always loop to the end index
// -todo: make function to move an index forward or backward? - not needed with rolling placement reordering
// -todo: make a function to remove any holes between an element and its ideal position
// -todo: make function to find spans of non-empty blocks, sort them and move them - not needed
// -todo: simplify test case and debug duplicates in concatenation - should reserve use a del() function combined with reinsertion? 
// -todo: revisit concactenation to make sure map elems are copied
// -todo: try reserve again - without recursion? - if curKV's ideal idx is the same, loop on the next idx. - problem, robin hood hashing would mean swapping if curKV's ideal is larger than the element at i, but if an element hasn't been moved, its distance to ideal could be large, meaning it wouldn't move even though it should 
//       | solution: don't do robbin hood hasing at first, just make sure all the elements that hash to the same bucket are linearly packed
//       |   problem: are there scenarios that will trigger infinite recursion? - yes, if only comparing ideal indices
//       |   problem: moving an element creates a hole - does that mean the elements in front should be moved back if it would make them closer to their ideal index?
//       |     solution: make a delete function that removes a key and checks elements forward to see if moving them one back would get them closer to their ideal position
//       |     solution: make a compact function that scans through looking for empty spaces and moves elements backwards if it would be more ideal - make the function start at an index and go until it hits an element already in its ideal position, returning the number of elements moved
// -todo: robin hood hashing
// -todo: make put into a template
// -todo: change place_rh to return reference
// -todo: change operator() to use put - not neccesary 
// -todo: change concatenation to use put() - not needed
// -todo: make a KV constructor that takes a key, hash and a value
// -todo: debug duplicate "two" entries - rolling placement wasn't using robin hood hasing
// -todo: make KVRef struct with a *this ptr and an index - make internal and external KV structs, with the external having a this ptr that can modify the table? - not needed
// -todo: give KV a default constructor and copy constructor so that the c_str key is copied?
// -todo: put comparison into place_rh
// -todo: test KV with key string above character length - fails with an assert
// -todo: make extend() enlarge based on map_capacity() instead of elems
// -todo: make and test del() function
// -todo: make capacity be increased when elems is within 75% or 4-6 of the map capacity
// -todo: make rolling reshuffle and put into delete function - not needed, but robin hood hasing will be needed
// -todo: integrate robin hood hasing into compact() - short circuiting 
// -todo: debug del() compact() not filling in holes after first call - only short circuit after prevElemDist is lower than elemDist, not lower of equal
// -todo: test with 64 byte KV and long key strings - seems to work fine
// -todo: make rolling reorder into a function
// -todo: make function to delete KV with NONE type? set NONE to empty? - make delete type function?
// -todo: make shrink_to_fit()
// -todo: change find() ideal() distance() and holeOfst to const
// -todo: update reserve() and constructor to set map capacity
// -todo: make operator-- be shrink_to_fit() and ++ be expand() ?
// -todo: redo unsigned types to not include an 'i'




